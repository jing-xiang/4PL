@page "/container-type-mapping"
@using System.Diagnostics
@using Microsoft.AspNetCore.Components.QuickGrid
@using _4PL.Data
@using Newtonsoft.Json
@inject IConfiguration Configuration
@inject HttpClient Http
@inject IJSRuntime JS
@inject NavigationManager NavManager
@attribute [Microsoft.AspNetCore.Authorization.Authorize]

@rendermode InteractiveServer

<PageTitle>Container Type Mapping</PageTitle>

<h3 class="container">Container Type Mapping</h3>
<div class="container">

    @if (!editTab)
    {
        <EditForm Model="addContainerTypeMapping" OnSubmit="CreateMapping" 
    Enhance
         >
             <label class="label-control">Add Mapping</label>
             <div class="row">
                 <div class="col-md-4">
                     <InputText @bind-Value="addContainerTypeMapping.Other_Container_Type_Name" placeholder="Other Container Type Name" class="form-control" autocomplete="off"></InputText>
                 </div>
                 <div class="col-md-4">
                     <InputText @bind-Value="addContainerTypeMapping.Source" placeholder="Source" class="form-control" autocomplete="off"></InputText>
                 </div>
                 <div class="col-md-4">
                    <label for="selectContainerType">Select Container Type:</label>
                     <InputSelect id="selectContainerType" @bind-Value="addContainerTypeMapping.Container_Type" autocomplete="off">
                         <option value=""></option>
                         @foreach (var ct in containerTypesList) {
                            <option value="@ct.Container_Type">@ct.Container_Type</option>
                        }
                    </InputSelect>
                </div>
            </div>
            <button type="submit" class="btn btn-primary my-2">Add</button>
        </EditForm>
    }
    else
    {
        <EditForm Model
        ="mappingToEdit" OnSubmit
        ="UpdateMapping"    
    Enhance
         >
             <label class="label-control">Update Mapping</label>
             <div class="row">
                 <div class="col-md-4">
                     <InputText @bind-Value="mappingToEdit.Other_Container_Type_Name" placeholder="Other Container Type Name" class="form-control" autocomplete="off"></InputText>
                 </div>
                 <div class="col-md-4">
                     <InputText @bind-Value="mappingToEdit.Source" placeholder="Source" class="form-control" autocomplete="off"></InputText>
                 </div>
                 <div class="col-md-4">
                    <label for="selectContainerType">Select Container Type:</label>
                     <InputSelect id="selectContainerType" @bind-Value="mappingToEdit.Container_Type">
                         <option value=""></option>
                         @foreach (var ct in containerTypesList)
                        {
                            <option value="@ct.Container_Type">@ct.Container_Type</option>
                        }
                    </InputSelect>
                </div>
            </div>
            <button type="submit" class="btn btn-primary my-2">Update</button>
        </EditForm>
    }
    <EditForm Model="searchContainerTypeMapping" OnSubmit="FetchMappings" 
    Enhance
     >
         <label class="label-control">Search Mapping</label>
         <div class="row">
             <div class="col-md-4">
                 <InputText @bind-Value="searchContainerTypeMapping.Other_Container_Type_Name" placeholder="Other Container Type Name" class="form-control" autocomplete="off"></InputText>
             </div>
             <div class="col-md-4">
                 <InputText @bind-Value="searchContainerTypeMapping.Source" placeholder="Source" class="form-control" autocomplete="off"></InputText>
             </div>
             <div class="col-md-4">
                 <label for="selectContainerType">Select Container Type:</label>
                 <InputSelect id="selectContainerType" @bind-Value="searchContainerTypeMapping.Container_Type">
                     <option value=""></option>
                     @foreach (var ct in containerTypesList)
                    {
                        <option value="@ct.Container_Type">@ct.Container_Type</option>
                    }
                </InputSelect>
            </div>
        </div>
        <button type="submit" class="btn btn-primary my-2">Search</button>
    </EditForm>
    <br />
    <QuickGrid Items="@ContainerTypeMappingsQueryable" @ref="grid" Pagination="pagination">
        <PropertyColumn Title="Other Container Type Name" Property="@(c => c.Other_Container_Type_Name)" Sortable="true" InitialSortDirection="SortDirection.Ascending"></PropertyColumn>
        <PropertyColumn Title="Source" Property="@(c => c.Source)" Sortable="true" InitialSortDirection="SortDirection.Ascending"></PropertyColumn>
        <PropertyColumn Title="Container Type" Property="@(c => c.Container_Type)" Sortable="true" InitialSortDirection="SortDirection.Ascending"></PropertyColumn>
        <TemplateColumn Title="Actions">
            <button @onclick="@(() => toggleEdit(context))" class="btn btn-success">Edit</button>
            <button @onclick="@(() => DeleteMapping(context))" class="btn btn-danger">Delete</button>
        </TemplateColumn>
    </QuickGrid>
    <Paginator State="@pagination" />

</div>

<style>
    table {
    font-family: arial, sans-serif;
    border-collapse: collapse;
    width: 100%;
    font-size: 14px;
    }

    td, th {
    border: 1px solid #dddddd;
    text-align: left;
    padding: 8px;
    }

    tr:nth-child(even) {
    background-color: #dddddd;
    }

    .result-container {
    width: 100%;
    overflow-x: auto;
    }

    .remarks-col {
    min-width: 300px;
    }
</style>


@code {
    IQueryable<ContainerTypeMappingReference> ContainerTypeMappingsQueryable = Enumerable.Empty<ContainerTypeMappingReference>().AsQueryable();
    private bool editTab = false;
    private ContainerTypeMappingReference prevMapping = new();
    private ContainerTypeMappingReference mappingToEdit = new();
    private List<ContainerTypeReference> containerTypesList = new();

    [SupplyParameterFromForm]
    ContainerTypeMappingReference addContainerTypeMapping { get; set; } = new();
    [SupplyParameterFromForm]
    ContainerTypeMappingReference searchContainerTypeMapping { get; set; } = new();

    QuickGrid<ContainerTypeMappingReference>? grid;
    PaginationState pagination = new PaginationState { ItemsPerPage = 10 };

    protected override async Task OnInitializedAsync()
    {
        containerTypesList = await Http.GetFromJsonAsync<List<ContainerTypeReference>>($"{Configuration["ApiBaseUrl"]}/api/ContainerTypeMapping/FetchContainerTypesList");
    }

    // async void toggleEdit(ChargeReference charge) {
    //     if (chargeToEdit != charge && chargeToEdit.editTab == true) {
    //         chargeToEdit.editTab = false; set the previous charge's edit tab to false
    //     }
    //     oldChargeCode = charge.Charge_Code;
    //     chargeToEdit = charge;
    //     chargeToEdit.editTab = !chargeToEdit.editTab; toggle current charge's edit tab
    // }

    async void toggleEdit(ContainerTypeMappingReference mapping)
    {
        if ((mapping.Other_Container_Type_Name != mappingToEdit.Other_Container_Type_Name || mapping.Source != mappingToEdit.Source)
        && editTab == true)
        { //if the new mapping to edit is different from the previous mapping to edit
            editTab = true;
        }
        else
        {
            editTab = !editTab;
        }
        prevMapping = mapping;
        mappingToEdit = new ContainerTypeMappingReference(mapping);
    }

    async Task CreateMapping()
    {
        searchContainerTypeMapping = new(); // clear if there were previous searches
        addContainerTypeMapping.Other_Container_Type_Name = addContainerTypeMapping.Other_Container_Type_Name.Trim();// trim leading and trailing spaces
        addContainerTypeMapping.Source = addContainerTypeMapping.Source.Trim();// trim leading and trailing spaces
        addContainerTypeMapping.Container_Type = addContainerTypeMapping.Container_Type.Trim();// trim leading and trailing spaces
        if (addContainerTypeMapping.Other_Container_Type_Name == "" || addContainerTypeMapping.Source == "" || addContainerTypeMapping.Container_Type == "")
        {
            await JS.InvokeVoidAsync("alert", "Please fill in the missing field(s)");
            return;
        }
        HttpResponseMessage response = await Http.PostAsJsonAsync($"{Configuration["ApiBaseUrl"]}/api/ContainerTypeMapping/CreateContainerTypeMapping", addContainerTypeMapping);
        string result = response.Content.ReadAsStringAsync().Result;
        if (result == "Error - duplicate primary keys")
        {
            await JS.InvokeVoidAsync("alert", "The inputted combination of other container type name and source already exists");
        }
        else
        {
            await JS.InvokeVoidAsync("alert", $"Successfully added container type mapping");
            StateHasChanged();
        }
        addContainerTypeMapping = new();
    }

    async Task DeleteMapping(ContainerTypeMappingReference mapping)
    {
        editTab = false;
        string confirmMessage = $"Confirm delete container type mapping with other name: {mapping.Other_Container_Type_Name} and source: {mapping.Source}?";
        bool confirmed = await JS.InvokeAsync<bool>("confirm", confirmMessage);
        if (confirmed)
        {
            HttpResponseMessage result = await Http.DeleteAsync($"{Configuration["ApiBaseUrl"]}/api/ContainerTypeMapping/DeleteContainerTypeMapping/{mapping.Other_Container_Type_Name}/{mapping.Source}");
            if (result.Content.ReadAsStringAsync().Result == "true")
            {
                await JS.InvokeVoidAsync("alert", $"Successfully deleted mapping with other name: {mapping.Other_Container_Type_Name} and source: {mapping.Source}");
                // Refresh and display
                await FetchMappings();

            }
            else
            {
                await JS.InvokeVoidAsync("alert", $"Failed to delete mapping with other name: {mapping.Other_Container_Type_Name} and source: {mapping.Source} -- Does not exist");
            }
            //addContainerTypeReference = new();
        }

    }

    async Task FetchMappings()
    {
        editTab = false;
        searchContainerTypeMapping.Other_Container_Type_Name = searchContainerTypeMapping.Other_Container_Type_Name.Trim();
        searchContainerTypeMapping.Source = searchContainerTypeMapping.Source.Trim(); // remove leading and trailing white spaces
        searchContainerTypeMapping.Container_Type = searchContainerTypeMapping.Container_Type.Trim();

        List<ContainerTypeMappingReference> items = new List<ContainerTypeMappingReference>();
        HttpResponseMessage result = await Http.PostAsJsonAsync<ContainerTypeMappingReference>($"{Configuration["ApiBaseUrl"]}/api/ContainerTypeMapping/FetchContainerTypeMappings", searchContainerTypeMapping);
        var resultContent = await result.Content.ReadAsStringAsync();
        items = JsonConvert.DeserializeObject<List<ContainerTypeMappingReference>>(resultContent);
        if (!items.Any()) await JS.InvokeVoidAsync("alert", $"No search results found"); // TODO: possibly more descriptive error message?

        ContainerTypeMappingsQueryable = items.AsQueryable();
        // Refresh and display
        StateHasChanged();
    }

    // TODO: Edit the Update/Edit mapping function that calls the API
    async Task UpdateMapping()
    {
        mappingToEdit.Other_Container_Type_Name = mappingToEdit.Other_Container_Type_Name.Trim();
        if (mappingToEdit.Other_Container_Type_Name == "" || mappingToEdit.Source == "" || mappingToEdit.Container_Type == "")
        {
            await JS.InvokeVoidAsync("alert", $"Updated field values cannot be empty");
            return;
        }
        else if (mappingToEdit.Other_Container_Type_Name == prevMapping.Other_Container_Type_Name
    && mappingToEdit.Source == prevMapping.Source && mappingToEdit.Container_Type == prevMapping.Container_Type) { 
            await JS.InvokeVoidAsync("alert", $"Updated container type mapping is identical to the original mapping");
            return;
    }
        HttpResponseMessage result = await Http.PostAsJsonAsync<ContainerTypeMappingReference>($"{Configuration["ApiBaseUrl"]}/api/ContainerTypeMapping/UpdateContainerTypeMapping", mappingToEdit);
        editTab = false;
        mappingToEdit = new();
        await FetchMappings(); 
        // TODO: if you have 2 pages, when you change a record on page 2, will the page refresh to page 1?
        //                       Keep this way first (can enhance speed and user experience later)
        //                       Manually update ChargesQueryable

        StateHasChanged(); // the field does not change immediately unless I fetch the search again

    }

}

